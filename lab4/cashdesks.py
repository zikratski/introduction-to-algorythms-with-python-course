# Смоделируйте, как количество касс влияет на время, проведенное в очереди, основываясь на следующих предположениях:
#
#     в магазине имеется C касс (от cash desks)
#     в единицу времени к кассам подходит N покупателей (для каждого известно время его обслуживание, пусть
#     это будут случайные числа от 1 до 5)
#
#     для генерации такой выборки используйте random.choices([1,2,3,4,5], weights=[0.45,0.25,0.15,0.10, 0.05], k=N) –
#     сумма весов равна 1, поэтому единица будет генерироваться в 45% случаев, двойка – в 25% и т.д.
#
#     покупатели более-менее равномерно распределяются по кассам, где их обслуживают по очереди
#
#     каждый пристраивается в очередь с наименьшим количеством покупателей
#
#     в единицу времени с каждого покупателя у кассы (первый в очереди) “снимается единица” его времени обслуживания:
#
#     например, если у него было 3, то станет 2 и он останется на следующие два хода у кассы
#     если же у него было (или осталось) 1, то станет 0 и покупатель покидает очередь
#     чтобы это сделать, достаньте покупателя слева, уменьшите его значение на 1 и, если не нуль, то верните в очередь
#     слева (чтобы он остался у кассы)
#
#     всего моделируется T ходов (единиц времени)
#     на каждом ходу (перед снятием единичек у покупателей) для каждой очереди вычисляется общая сумма времени покупателей,
#     затем находится среднее значение, которое добавляется в список
#     этот список выводится в результате выполнения программы
#
# Напишите программу cashdesks.py, которая реализует приведенную выше схему для заданных 1) количества покупателей N
# в единицу времени, 2)  количества касс C, 3) количества ходов T.

from queuedummy import Queue
import sys, random
def func(n,c,t):
    arr_queues = [Queue() for i in range(c)]
    #print(arr_queues)
    sums = []
    for timeunit in range(t):
        new_peoples = random.choices([1, 2, 3, 4, 5], weights=[0.45, 0.25, 0.15, 0.10, 0.05], k=n)
        for people in new_peoples:
            lens = [elem.queueLen() for elem in arr_queues]
            imin = lens.index(min(lens))
            arr_queues[imin].enqueue(people)

        sums.append(timemed(arr_queues))

        for que in arr_queues:
            if not que.is_empty():
                que.changeFirstEl(-1)
                if que.peek() == 0:
                    que.dequeue()

    return sums

def timemed(arr_queues):
    s = 0
    count = 0
    for q in arr_queues:
        for i in q.items:
            s += i
        count += 1
    return round(s/count,2)

if __name__ == '__main__':
    n = int(sys.argv[1]) #количество покупателей в единицу времени
    c = int(sys.argv[2]) #количество касс
    t = int(sys.argv[3]) #количество ходов

    # n = 3
    # c = 8
    # t = 20
    sums = func(n,c,t)
    print(sums)